\documentclass[a4paper]{article}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%
%%% Zuerst laden wir ein paar nützliche Pakete
%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% AMS-Pakete: mathematische Fonts
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{amsmath}
\usepackage{amssymb}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Babel-Paket: Silbentrennung (Deutsch/neue Rechtschtreibung)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage[english,ngerman]{babel}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% fontenc & inputenc: Umlaute in UTF8 eingeben
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% graphicx: Graphiken einbinden
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{graphicx}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% color: farbige Texte, Hintergründe, Links, etcpp.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{color}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% tikz/pgfplots: Bilder in LaTeX zeichnen
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{tikz}
\usetikzlibrary{decorations.pathmorphing,patterns,calc}
\usepackage{pgfplots}
\pgfplotsset{compat=1.12}
\usepackage{calculus}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% geometry: bessere Ausnutzung des verfügbaren Platzes
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage[a4paper,includeheadfoot,margin=2.54cm]{geometry}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% epstopdf: automatische Umwandlung von EPS nach PDF
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{epstopdf}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%
%%% Nun definieren wir ein paar hilfreiche Dinge
%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Generelles Umstellen des Doppelpunktes auf dieselbe
% Linie wie das Gleichheitszeichen. Aus de-tex-faq, Teil 8,
% Makro von Donald Arseneau
%
\mathchardef\ordinarycolon\mathcode`\:
\mathcode`\:=\string"8000
\begingroup \catcode`\:=\active
  \gdef:{\mathrel{\mathop\ordinarycolon}}
\endgroup
%%
%% definition of Perlis mathclap etcpp.
%%
% For comparison, the existing overlap macros:
% \def\llap#1{\hbox to 0pt{\hss#1}}
% \def\rlap#1{\hbox to 0pt{#1\hss}}
\def\clap#1{\hbox to 0pt{\hss#1\hss}}
\def\mathllap{\mathpalette\mathllapinternal}
\def\mathrlap{\mathpalette\mathrlapinternal}
\def\mathclap{\mathpalette\mathclapinternal}
\def\mathllapinternal#1#2{%
  \llap{$\mathsurround=0pt#1{#2}$}}
\def\mathrlapinternal#1#2{%
  \rlap{$\mathsurround=0pt#1{#2}$}}
\def\mathclapinternal#1#2{%
  \clap{$\mathsurround=0pt#1{#2}$}}
%%
%% end of perlis stuff
%%
%%
%% definition of inverse diagonal dots (iddots)
%%
\makeatletter
\def\iddots{\mathinner{\mkern1mu\raise\p@%
    \hbox{.}\mkern2mu\raise4\p@\hbox{.}\mkern2mu%
    \raise7\p@\vbox{\kern7\p@\hbox{.}}\mkern1mu}}
\makeatother
%%%\def\ddots{\mathinner{\mkern1mu\raise7\p@\vbox%
%%%{\kern7\p@\hbox{.}} \mkern2mu\raise4\p@\hbox{.}%
%%%\mkern2mu\raise\p@\hbox{.}\mkern1mu}}
%
% TIME OF DAY (Nelson H. F. Beebe :-)
%
\newcount\hh
\newcount\mm
\mm=\time
\hh=\time
\divide\hh by 60
\divide\mm by 60
\multiply\mm by 60
\mm=-\mm
\advance\mm by \time
\def\hhmm{\number\hh:\ifnum\mm<10{}0\fi\number\mm}
%
% Use it like this in a LaTeX document:
%
%        \date{\today{ }\hhmm}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%
%%% Wir definieren Makros für fette Buchstaben
%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% small bold letters
\newcommand{\bfa}{{\mathbf a}}
\newcommand{\bfb}{{\mathbf b}}
\newcommand{\bfc}{{\mathbf c}}
\newcommand{\bfd}{{\mathbf d}}
\newcommand{\bfe}{{\mathbf e}}
\newcommand{\bff}{{\mathbf f}}
\newcommand{\bfg}{{\mathbf g}}
\newcommand{\bfh}{{\mathbf h}}
\newcommand{\bfi}{{\mathbf i}}
\newcommand{\bfj}{{\mathbf j}}
\newcommand{\bfk}{{\mathbf k}}
\newcommand{\bfl}{{\mathbf l}}
\newcommand{\bfm}{{\mathbf m}}
\newcommand{\bfn}{{\mathbf n}}
\newcommand{\bfo}{{\mathbf o}}
\newcommand{\bfp}{{\mathbf p}}
\newcommand{\bfq}{{\mathbf q}}
\newcommand{\bfr}{{\mathbf r}}
\newcommand{\bfs}{{\mathbf s}}
\newcommand{\bft}{{\mathbf t}}
\newcommand{\bfu}{{\mathbf u}}
\newcommand{\bfv}{{\mathbf v}}
\newcommand{\bfw}{{\mathbf w}}
\newcommand{\bfx}{{\mathbf x}}
\newcommand{\bfy}{{\mathbf y}}
\newcommand{\bfz}{{\mathbf z}}
%%% capital bold letters
\newcommand{\bfA}{{\mathbf A}}
\newcommand{\bfAT}{{\mathbf A}\kern-.15em^{\mathsf{T}}}
\newcommand{\bfB}{{\mathbf B}}
\newcommand{\bfC}{{\mathbf C}}
\newcommand{\bfD}{{\mathbf D}}
\newcommand{\bfE}{{\mathbf E}}
\newcommand{\bfF}{{\mathbf F}}
\newcommand{\bfG}{{\mathbf G}}
\newcommand{\bfH}{{\mathbf H}}
\newcommand{\bfI}{{\mathbf I}}
\newcommand{\bfJ}{{\mathbf J}}
\newcommand{\bfK}{{\mathbf K}}
\newcommand{\bfL}{{\mathbf L}}
\newcommand{\bfM}{{\mathbf M}}
\newcommand{\bfN}{{\mathbf N}}
\newcommand{\bfO}{{\mathbf O}}
\newcommand{\bfP}{{\mathbf P}}
\newcommand{\bfQ}{{\mathbf Q}}
\newcommand{\bfR}{{\mathbf R}}
\newcommand{\bfS}{{\mathbf S}}
\newcommand{\bfT}{{\mathbf T}}
\newcommand{\bfU}{{\mathbf U}}
\newcommand{\bfV}{{\mathbf V}}
\newcommand{\bfW}{{\mathbf W}}
\newcommand{\bfX}{{\mathbf X}}
\newcommand{\bfY}{{\mathbf Y}}
\newcommand{\bfZ}{{\mathbf Z}}
%% extra bold symbols
\newcommand{\bfell}{{\boldsymbol{\ell}}}
\newcommand{\bfLambda}{{\boldsymbol{\Lambda}}}
\newcommand{\bfSigma}{{\boldsymbol{\Sigma}}}
\newcommand{\bfnu}{{\boldsymbol{\nu}}}
\newcommand{\bfphi}{{\boldsymbol{\phi}}}
\newcommand{\bfalpha}{{\boldsymbol{\alpha}}}
\newcommand{\bfbeta}{{\boldsymbol{\beta}}}
\newcommand{\bfhatbeta}{{\boldsymbol{\widehat{\beta}}}}
\newcommand{\bfomega}{{\boldsymbol{\omega}}}
\newcommand{\bfrho}{{\boldsymbol{\rho}}}
\newcommand{\bfmu}{{\boldsymbol{\mu}}}
\newcommand{\bfchecknu}{{\boldsymbol{\check{\nu}}}}
\newcommand{\bfhatnu}{{\boldsymbol{\widehat{\nu}}}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%
%%% Zum Setzen von Sätzen, Beweisen, Lemmata, Definitionen
%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{amsthm}
\newtheorem{theorem}{Satz}[section]
\newtheorem{lemma}[theorem]{Lemma}%[section]
\newtheorem{corollary}[theorem]{Korollar}%[section]
\theoremstyle{definition}
\newtheorem{definition}[theorem]{Definition}%[section]
\newtheorem{remark}[theorem]{Bemerkung}%[section]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%
%%% Mathematische Operatoren in \textsf
%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\renewcommand{\det}{\mathop{\mathsf{det}}}
\newcommand{\adj}{\mathop{\mathsf{adj}}}
\renewcommand{\dim}{\mathop{\mathsf{dim}}}
\renewcommand{\deg}{\mathop{\mathsf{deg}}}
\renewcommand{\max}{\mathop{\mathsf{max}}}
\renewcommand{\min}{\mathop{\mathsf{min}}}
\newcommand{\argmin}{\mathop{\mathsf{arg\ min}}}
\newcommand{\diag}{\mathop{\mathsf{diag}}}
\newcommand{\triu}{\mathop{\mathsf{triu}}}
\newcommand{\tril}{\mathop{\mathsf{tril}}}
\newcommand{\ones}{\mathop{\mathsf{ones}}}
\newcommand{\zeros}{\mathop{\mathsf{zeros}}}
\newcommand{\eye}{\mathop{\mathsf{eye}}}
\newcommand{\conj}{\mathop{\mathsf{conj}}}
\newcommand{\norm}{\mathop{\mathsf{norm}}}
\newcommand{\Mod}{\mathop{\mathsf{mod}}}
\newcommand{\spdiags}{\mathop{\mathsf{spdiags}}}
\newcommand{\circshift}{\mathop{\mathsf{circshift}}}
\newcommand{\fliplr}{\mathop{\mathsf{fliplr}}}
\newcommand{\logical}{\mathop{\mathsf{logical}}}
\newcommand{\Summe}{\mathop{\mathsf{sum}}}
\newcommand{\sign}{\mathop{\mathsf{sign}}}
\newcommand{\cumprod}{\mathop{\mathsf{cumprod}}}
\renewcommand{\limsup}{\mathop{\mathsf{lim\ sup}}}
\newcommand{\spur}{\mathop{\mathsf{spur}}}
\renewcommand{\vec}{\mathop{\mathsf{vec}}}
\newcommand{\spec}{\mathop{\mathsf{spec}}}
\newcommand{\speceps}{\mathop{\mathsf{spec}_{\epsilon}}}
\newcommand{\Bild}{\mathop{\mathsf{Bild}}}
\newcommand{\Kern}{\mathop{\mathsf{Kern}}}
\newcommand{\Span}{\mathop{\mathsf{span}}}
\newcommand{\Index}{\mathop{\mathsf{Index}}}
\newcommand{\Rang}{\mathop{\mathsf{Rang}}}
% hack for seto = searrow in small
\newcommand{\seto}{\mathop{\scalebox{.5}{$\searrow$}}}
\newcommand{\neto}{\mathop{\scalebox{.5}{$\nearrow$}}}
% end of hack for seto = searrow in small
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%
%%% kleiner Hack, um Einträge in Matrizen anders auszurichten
%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\makeatletter
\renewcommand*\env@matrix[1][*\c@MaxMatrixCols c]{%
  \hskip -\arraycolsep
  \let\@ifnextchar\new@ifnextchar
  \array{#1}}
\makeatother
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%
%%% Wir wollen Matlab-Beispielprogramme einbinden
%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{listings}
\definecolor{hellgrau}{rgb}{0.90,0.90,0.90}
\definecolor{commentcol}{rgb}{0.0823,.4902,0.0}
\lstset{language=Matlab,
        basicstyle={\footnotesize\ttfamily},
        keywordstyle={\sffamily\bfseries},
        tabsize=2,
        escapechar=\#,
        numbers=left,
        numberstyle=\tt,
        stepnumber=1,
        numbersep=7pt,
        breaklines=true,
        frame=single,
        frameround=ffff,
        commentstyle=\color{commentcol},
        backgroundcolor=\color{hellgrau}
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%
%%% Wir wollen verlinkte PDF-Dateien, dazu ein paar Zeilen
%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{ifpdf}
\ifpdf
\usepackage[pdftex]{hyperref}
\usepackage{thumbpdf}
\else
\usepackage[dvips,ps2pdf,naturalnames]{hyperref}
\fi
\definecolor{mycolor}{rgb}{.08,.12,.71}
\hypersetup{%
  pdftitle     = {Gaußsches Eliminationsverfahren mit Pivotisierung},
  pdfsubject   = {Proseminar Mathematik},
  pdfkeywords  = {Proseminar, Mathematik, numerische lineare Algebra,
    TUHH, Pivotisierung},
  pdfauthor    = {\textcopyright\ Rustam Magomedov 2017},
  pdfstartview = {FitH},
  pdfview      = {FitH},
  linkcolor    = mycolor,     % links to same page
  urlcolor     = mycolor,     % links to URLs
  citecolor    = mycolor,     % links to citations
  breaklinks   = true,       % links may (line) break
  colorlinks   = true,
  citebordercolor=0 0 0,  % color for \cite
  filebordercolor=0 0 0,
  linkbordercolor=0 0 0,
  menubordercolor=0 0 0,
  urlbordercolor=0 0 0,
  pdfhighlight=/P,   % moeglich /I, /P, ...
  pdfborder=0 0 0,   % keine Box um die Links!
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%
%%% Zum Setzen von Algorithmen
%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{algorithmic}
\renewcommand{\algorithmiccomment}[2]{\hfill\rlap{\texttt{\%
      #1}}\phantom{\texttt{\% #2}}}
\renewcommand{\algorithmicrequire}{\textsc{Eingabe:}}
\renewcommand{\algorithmicensure}{\textsc{Ausgabe:}}
\usepackage[Algorithmus]{algorithm}
\numberwithin{algorithm}{section}
%%%
\usepackage{hypcap}
\renewcommand{\hypcapspace}{0pt}

\newcommand{\mnorm}[1]{\left\lVert#1\right\rVert}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%
%%% … endlich geht es los!
%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%





\begin{document}

\title{\Huge \textbf{Gaußsches Eliminationsverfahren mit Pivotisierung}}
\author{\textsc{Rustam Magomedov}}
\date{\today}
\maketitle%
\tableofcontents%
\newpage


%========================================
\phantomsection
\addcontentsline{toc}{section}{Algorithmenverzeichnis}%
\listof{algorithm}{Algorithmenverzeichnis}%
\newpage


%========================================
\section{Einführung}
\label{sec:introduction}
In dieser Ausarbeitung werden wir uns mit den unterschiedlichen Pivotisierungsverfahren, 
die in der Numerische Linearen Algebra eine wichtige Rolle spielen, beschäftigen. 
Dies werden wir mithilfe des im Proseminar vorgestellten Buches von Watkins \cite{watkins:pivoting}, 
des Skripts \cite{zemke:growth} und mithilfe einiger Internetquellen \cite{chemnitz:rounding}, 
die im Literaturverzeichnis aufgelistet sind, tun. 
Die Ausarbeitung ist in drei Abschnitte aufgeteilt um die strukturierte Behandlung des Themas 
zu ermöglichen. Im ersten Abschnitt werden wir erfahren welche Motivation hinter diesen 
Verfahren steckt und werden ein Paar wichtige Begriffe, die uns im dritten Abschnitt bei 
der Auswertung helfen werden, kennen lernen. Im zweiten Abschnitt schauen wir uns die 
Verfahren näher an und machen uns mit den Algorithmen vertraut. Wie schon vorher erwähnt, 
werden wir im letzten Abschnitt dieser Ausarbeitung die, nun bekannten, Verfahren auswerten 
und miteinander vergleichen.


%========================================
\subsection{Motivation}
\label{sec:motivation}
LR-Zerlegung stellt ein gutes numerisches Verfahren dar und ist beim Lösen eines 
eindeutig lösbaren Gleichungssystems, wo eine reguläre Matrix auftritt, kaum ersetzbar, 
jedoch hat auch die LR-Zerlegung ihre Nachteile. Ein typisches Beispiel, bei dem LR-Zerlegung 
nicht anwendbar ist, ist eine reguläre Matrix mit einer Null in der ersten Komponente, zwar ist 
diese Matrix regulär, es lässt sich aber trotzdem kein sinnvolles Ergebnis ohne weiteres 
erschließen. Ein anschauliches Beispiel dazu:

\begin{verbatim}
>> A = [0 2 -3; 2 2 1; 2 4 4]
A =
     0    2   -3
     2    2    1
     2    4    4

>> det(A)
ans = -24

\end{verbatim}


%========================================
\subsection{Rechnergenauigkeit}
\label{sec:precision}
Ein weiterer Grund, warum es ohne eine weitere Methode nicht geht und neue Lösungsverfahren 
von essentieller Bedeutung sind, sind die physikalischen Eigenschaften moderner Rechner. 
Eine reelle Zahl lässt zwar auf dem Blatt Papier verhältnismässig einfach darstellen, 
wobei es selbst hier sich um eine begrenzte Anzahl der Nachkommastellen handeln muss, 
sind die Speicherkapazitäten eines Rechners für manche mathematischen Operationen sehr begrenzt. 
Dies führt wiederum zu neuen Speicherformaten und eines dieser Formate ist das IEEE-Format. 
Das IEEE-Format bringt nicht nur bessere Speicherverwaltung mit, indem es erlaubt 
Gleitkommazahlen besser zu speichern, sondern auch Rundungsfehler, was sich am folgenden 
Beispiel \cite{chemnitz:rounding} anschaulich darstellen lässt:

\begin{equation}
  \bfA=\bfL\bfR
  \quad\Rightarrow\quad
  \begin{pmatrix}
    10^{-20}  & 1 \\
    1         & 1 \\
  \end{pmatrix}=
  \begin{pmatrix}
    1         & 0 \\
    10^{20}   & 1 \\
  \end{pmatrix}
  \begin{pmatrix}
    10^{-20}  & 1 \\
    0         & 1-10^{20} \\
  \end{pmatrix},
\end{equation}
\newline

\noindent wo $\bfA$ eine reguläre Matrix mit einer LR-Zerlegung ist, bei der $\bfL$ eine normierte 
untere und $\bfR$ eine rechte obere Dreiecksmatrix ist. In diesem Beispiel entsteht ein Problem 
bei dem $r_{22}$-Eintrag der $\bfR$-Matrix. Wird man die beiden Matrizen $\bfL$ und $\bfR$ 
ausmutiplizieren, so wird man nicht auf die ursprüngliche Matrix $\bfA$ kommen, 
weil der $r_{22}$-Eintrag einen falschen Wert, der durch Rundungsfehler entsteht, liefert.


%========================================
\subsection{Begriffe}
\label{sec:concepts}
Um die Störungsempfindlichkeit der Verfahren auszuwerten führen wir neue Begriffe ein, 
diese Begriffe sollen die Grundlage, die der Auswertung dieser Verfahren dient, bilden. 
Der erste Begriff, den wir einführen, ist die Konditionszahl \cite{zemke:growth}, die ein Maß für die 
Störungsschwankung des Problems ist, und der zweite Begriff ist die Wachstumsfaktor \cite{zemke:growth}, 
dieser soll als Maß für die Stabilität (Stärke der Störungsschwankung des numerischen 
Algorithmus).
\newline
\newline
Die Konditionszahl ist definiert als: $$\kappa(A)=\mnorm{A^{-1}}\mnorm{A},$$
\newline
wobei $\bfA$ eine reguläre Matrix und $\mnorm{\cdot}$ eine Matrixnorm ist, 
von der die Konditionszahl abhängt.
\newline
Je kleiner die Konditionszahl ist, desto besser. 
Bei einer Konditionszahl $\epsilon\kappa(A) \sim 1$, wobei $\epsilon$ die relative 
Maschinengenauigkeit ist, kann man keine brauchbare Lösung erwarten.
\newline
\newline
Der Wachstumsfactor ist definiert als: $$\rho=^{\max\limits_{i,j} \left|r_{i,j}\right|}/_{\max\limits_{i,j} \left|a_{i,j}\right|},$$
\newline
wo $k$ für den Algorithmusschritt und $r_{i,j}$ und $a_{i,j}$ für entsprechende Einträge 
der $\bfA$ und $\bfR$ Matrizen stehen. Dabei gehen wir von der gängigen Konvention aus, 
bei der $\bfA$ eine reguläre Startmatrix und $\bfR$ eine obere Dreiecksmatrix ist. 
Auch bei dem Wachstumsfaktor heißt es je kleiner, desto besser.
\newpage


%========================================
\section{Verfahren}
\label{sec:methods}
In diesem Abschnitt der Ausarbeitung machen wir uns mit den drei Pivotisierungsverfahren 
bekannt und schauen uns die algorithmische Vorgehensweise dieser Methoden an.


%========================================
\subsection{Partielle Pivotisierung}
\label{sec:partial_pivoting}
Die partielle Pivotisierung \cite{watkins:pivoting}, die auch als Spaltenpivotsuche bekannt ist, ist die 
einfachste und die am meisten verbreitete Methode der Pivot-Suche. Bei dieser Methode sucht man das 
betragsmäßig größte Element, um es mit dem aktuellen Pivot-Element auszutauschen. Die Suche 
startet in der aktuellen Spalte und unter dem aktuellen Pivot-Element. Findet man das 
betragsmäßig größere Element, so tauscht man die Zeile mit dem betragsgrößten Element mit der 
Zeile des aktuellen Pivot-Elements um und speichert die Tauschoperation in einer Pivot-Matrix 
oder, wenn man es effizienter speichern möchte, in einem Pivot-Vektor. Diese Vorgehensweise 
wiederholt man solange bis man am letzten Pivot-Element landet, hier hört die Suche auf, da es 
keine weiteren Elemente mehr darunter gibt.

\begin{algorithm}
\caption{Partielle Pivotisierung%
  \label{alg:partial_pivoting}}
  \begin{algorithmic}[1]
    % Ein- und Ausgabe
    \REQUIRE $\bfA\in\mathbb{R}^{n\times n}$ mit $\Rang(\bfA)=n$.
    \ENSURE $\bfL\in\mathbb{R}^{n\times n}$ normierte untere Dreiecksmatrix, $\bfR\in\mathbb{R}^{n\times n}$ rechte obere Dreiecksmatrix und orthogonale Permutationsmatrix $\bfP\in\mathbb{R}^{n\times n}$.
    % Initialisierung
    \STATE $[n,n] \leftarrow \textsf{size}(\bfA)$;
    \STATE $\bfR \leftarrow \bfA$, $\bfL \leftarrow \bfP \leftarrow \textsf{eye}(n,n)$;
    % Schleife
    \FOR{$k = 1:n-1$}
      % Finde betragsmäßig maximales Element
      \STATE $[r_{max},i_{max}] \leftarrow \max\limits_{k \leq i \leq n}\{|r_{i,k}|\}$
      % Zeilenaustausch
      \IF{$i_{max} \neq k$}
        \STATE $\bfR([k\textsf{ }i_{max}],:) \leftarrow \bfR([i_{max}\textsf{ }k],:)$
        \STATE $\bfP([k\textsf{ }i_{max}],:) \leftarrow \bfP([i_{max}\textsf{ }k],:)$
      \ENDIF
      % Berechnung der Koeffizienten-Spalte in der L-Matrix
      \STATE $\bfL(k+1:n,k) \leftarrow \bfR(k+1:n,k)/r_{k,k}$
      % Berechnung der Zeile in der R-Matrix
      % \STATE $\bfR(k+1:n,k:n) \leftarrow \bfR(k+1:n,k:n) - diag(\bfL(k+1:n,k:n)) * repmat(\bfR(k,k:n), n-k, 1)$
      \FOR{$l = k:n-1$}
        \STATE $\bfR(l+1,k:n) \leftarrow \bfR(l+1,k:n) - \bfL(l+1,k) * \bfR(k,k:n)$
      \ENDFOR
    \ENDFOR
  \end{algorithmic}
\end{algorithm}
\newpage


%========================================
\subsection{Totale Pivotisierung}
\label{sec:total_pivoting}
Im Gegensatz zur partiellen Pivot-Suche wird bei dieser Methode \cite{watkins:pivoting} nicht nur 
die aktuelle Spalte unter dem aktuellen Pivot-Element, sondern die ganze Blockmatrix darunter durchsucht. 
Wird irgendwo in dieser Blockmatrix ein betragsmäßig größeres Element gefunden, so tauscht man die 
Zeilen und Spalten des aktuellen Pivot-Elements und des neu gefundenen betragsmäßig größeren 
Elements. Ein solches Verfahren resultiert in einer aufwändigeren Pivot-Suche, liefert jedoch 
bessere Ergebnisse, da die ganze Blockmatrix durchsucht wird und ein betragsmäßig 
größtes Element gefunden wird.

\begin{algorithm}
\caption{Totale Pivotisierung%
  \label{alg:total_pivoting}}
  \begin{algorithmic}[2]
    % Ein- und Ausgabe
    \REQUIRE $\bfA\in\mathbb{R}^{n\times n}$ mit $\Rang(\bfA)=n$.
    \ENSURE $\bfL\in\mathbb{R}^{n\times n}$ normierte untere Dreiecksmatrix, $\bfR\in\mathbb{R}^{n\times n}$ rechte obere Dreiecksmatrix und orthogonale Permutationsmatrizen $\bfP\in\mathbb{R}^{n\times n}$ und $\bfQ\in\mathbb{R}^{n\times n}$.
    % Initialisierung
    \STATE $[n,n] \leftarrow \textsf{size}(\bfA)$;
    \STATE $\bfR \leftarrow \bfA$, $\bfL \leftarrow \bfP \leftarrow \bfQ \leftarrow \textsf{eye}(n,n)$;
    % Schleife
    \FOR{$k = 1:n-1$}
      % Finde betragsmäßig maximales Element
      \STATE $[r_{max},i_{max},j_{max}] \leftarrow \max\limits_{k \leq i \leq n, k \leq j \leq n}\{|r_{i,j}|\}$
      % Zeilenaustausch
      \IF{$i_{max} \neq k$}
        \STATE $\bfR([k\textsf{ }i_{max}],:) \leftarrow \bfR([i_{max}\textsf{ }k],:)$
        \STATE $\bfP([k\textsf{ }i_{max}],:) \leftarrow \bfP([i_{max}\textsf{ }k],:)$
      \ENDIF
      % Spaltenaustausch
      \IF{$j_{max} \neq k$}
        \STATE $\bfR(:,[k\textsf{ }j_{max}]) \leftarrow \bfR(:,[j_{max}\textsf{ }k])$
        \STATE $\bfQ(:,[k\textsf{ }j_{max}]) \leftarrow \bfQ(:,[j_{max}\textsf{ }k])$
      \ENDIF
      % Berechnung der Koeffizienten-Spalte in der L-Matrix
      \STATE $\bfL(k+1:n,k) \leftarrow \bfR(k+1:n,k)/r_{k,k}$
      % Berechnung der Zeile in der R-Matrix
      % \STATE $\bfR(k+1:n,k:n) \leftarrow \bfR(k+1:n,k:n) - diag(\bfL(k+1:n,k:n)) * repmat(\bfR(k,k:n), n-k, 1)$
      \FOR{$l = k:n-1$}
        \STATE $\bfR(l+1,k:n) \leftarrow \bfR(l+1,k:n) - \bfL(l+1,k) * \bfR(k,k:n)$
      \ENDFOR
    \ENDFOR
  \end{algorithmic}
\end{algorithm}
\newpage


%========================================
\subsection{Rook-Pivotisierung}
\label{sec:rook_pivoting}
Die Rook-Pivotisierung \cite{zemke:growth} ist die neueste aller drei Methoden. Hier, genau wie bei der partiellen 
Pivot-Suche fängt man mit der aktuellen Spalte an. Falls ein betragsmäßig größeres Element als 
der Betrag des aktuellen Pivot-Elements gefunden wird, wird die Suche horizontal in der Zeile 
des betragsmäßig größeren Elements, fortgesetzt. Also, jedes Mal, wenn ein betragsmäßig größeres 
Element gefunden wird, wird die Suche in der Spalte oder Zeile des neu ausgesuchten Elements, 
abwechselnd fortgesetzt. Sobald kein betragsmäßig größeres Element gefunden wird, wird das 
zuletzt gefundene Element als das neue Pivot-Element ausgewählt und die Suche wird in der 
nächsten Spalte fortgesetzt.

\begin{algorithm}
\caption{Rook-Pivotisierung%
  \label{alg:rook_pivoting}}
  \begin{algorithmic}[3]
    % Ein- und Ausgabe
    \REQUIRE $\bfA\in\mathbb{R}^{n\times n}$ mit $\Rang(\bfA)=n$.
    \ENSURE $\bfL\in\mathbb{R}^{n\times n}$ normierte untere Dreiecksmatrix, $\bfR\in\mathbb{R}^{n\times n}$ rechte obere Dreiecksmatrix und orthogonale Permutationsmatrizen $\bfP\in\mathbb{R}^{n\times n}$ und $\bfQ\in\mathbb{R}^{n\times n}$.
    % COMMENT , $\bf{PA}=\bf{LR}$.
    % Initialisierung
    \STATE $[n,n] \leftarrow \textsf{size}(\bfA)$
    \STATE $\bfR \leftarrow \bfA$, $\bfL \leftarrow \bfP \leftarrow \bfQ \leftarrow \textsf{eye}(n,n)$;
    % Schleife
    \FOR{$k = 1:n-1$}
      % Finde betragsmäßig maximales Element
      \STATE $r_{max} \leftarrow r_{kk}$, $[r_{col}, i_{max}] \leftarrow \max\limits_{k \leq i \leq n}\{|r_{i,k}\}|$, $r_{row} \leftarrow it \leftarrow 0$
      \WHILE{$r_{max} < r_{col}$ or $r_{max} < r_{row}$}
        \STATE $r_{max} \leftarrow \max\{r_{row}, r_{col}\}$
        \IF{$it$ is odd}
        \STATE $[r_{col}, i_{max}] \leftarrow \max\limits_{k \leq i \leq n}\{|r_{i,j_{max}}|\}$
        \ELSE
        \STATE $[r_{row}, j_{max}] \leftarrow \max\limits_{k \leq j \leq n}\{|r_{i_{max},j}|\}$
        \ENDIF
        \STATE $it++$
      \ENDWHILE
      \STATE $r_{max} \leftarrow \max\{r_{row}, r_{col}\}$
      % Zeilenaustausch
      \IF{$i_{max} \neq k$}
        \STATE $\bfR([k\textsf{ }i_{max}],:) \leftarrow \bfR([i_{max}\textsf{ }k],:)$
        \STATE $\bfP([k\textsf{ }i_{max}],:) \leftarrow \bfP([i_{max}\textsf{ }k],:)$
      \ENDIF
      % Spaltenaustausch
      \IF{$j_{max} \neq k$}
        \STATE $\bfR(:,[k\textsf{ }j_{max}]) \leftarrow \bfR(:,[j_{max}\textsf{ }k])$
        \STATE $\bfQ(:,[k\textsf{ }j_{max}]) \leftarrow \bfQ(:,[j_{max}\textsf{ }k])$
      \ENDIF
      % Berechnung der Koeffizienten-Spalte in der L-Matrix
      \STATE $\bfL(k+1:n,k) \leftarrow \bfR(k+1:n,k)/r_{k,k}$
      % Berechnung der Zeile in der R-Matrix
      % \STATE $\bfR(k+1:n,k:n) \leftarrow \bfR(k+1:n,k:n) - diag(\bfL(k+1:n,k:n)) * repmat(\bfR(k,k:n), n-k, 1)$
      \FOR{$l = k:n-1$}
        \STATE $\bfR(l+1,k:n) \leftarrow \bfR(l+1,k:n) - \bfL(l+1,k) * \bfR(k,k:n)$
      \ENDFOR
    \ENDFOR
  \end{algorithmic}
\end{algorithm}
\newpage


%========================================
\section{Vergleich}
\label{sec:comparison}
Alle drei Pivotsuchverfahren können zur Pivotsuche eingesetzt werden, haben aber 
unterschiedliche Charakteristiken, aus diesem Grund wird meistens eine oder andere 
dieser Methoden in unterschiedlichen Fällen bevorzugt. Matlab verwendet beispielsweise 
die partielle Pivotsuche für eigene Implementierung der LR-Zerlegung.


%========================================
\subsection{Komplexität}
\label{sec:complexity}
Die partielle Pivotsuche ist die einfachste aller dieser drei Methoden und hat die geringste 
Suchkomplexität, die als $^{n^{2}}/_2 \in O(n^2)$ \cite{poole:cost} abgeschätzt wird, da aber nur die aktuelle 
Spalte durchsucht wird, liefert die partielle Pivotsuche oft kein optimales Ergebnis. Dagegen 
liefert die totale Pivotisuche das beste Suchergebnis, jedoch ist dieses Suchverfahren 
deutlich aufwändiger als die partielle Pivot-Suche. Die Suchkomplexität der totalen Pivotsuche 
liegt bei $^{n^{3}}/_3 \in O(n^3)$ \cite{poole:cost}. Die Rook-Pivotsuche ist eine vergleichsweise neue 
Suchmethode, die gute Ergebnisse liefert. Mit der statistisch nachgewiesenen Suchkomplexität 
von $^{3n^{2}}/_2 \in O(n^2)$ \cite{poole:cost} ist diese Methode beinah so gut wie die partielle Pivotsuche 
und liefert gute Ergebnisse, die mit den Ergebnissen der totalen Pivotsuche vergleichbar sind.


%========================================
\subsection{Stabilität}
\label{sec:stability}
Was die Stabilität angeht, steht die totale Pivotsuche, gefolgt von der Rook-Pivotsuche, mit 
ihrem Wachstumsfaktor von $\rho^{GETP}_n \leq 2\sqrt{n}n^{\ln(n)/4} \text{ für } n \geq 1$, an 
der ersten Stelle \cite{zemke:growth}. Das Durchsuchen der ganzen Untermatrix nach einem optimalen Element macht 
zwar die Suche aufwändig, liefert jedoch das beste Ergebnis und erhöht dadurch die Stabilität 
des Verfahrens. Die Rook-Pivotsuche, die an der zweiten Stelle steht, besitzt einen Wachstumsfaktor 
von $\rho^{GERP}_n \leq 1.5n^{3\ln(n)/4} \text{ für } n \geq 1$ \cite{zemke:growth} und zeichnet sich dadurch aus, 
dass die Suche deutlich einfacher ist als die bei der totalen Pivotsuche und vergleichbar nur mit 
der Komplexität der partiellen Pivotsuche, die trotz ihrer Instabilität mit ihrem Wachstumsfaktor 
von $\rho^{GEPP}_n \leq 2^{n-1} \text{ für } n \geq 1$ \cite{zemke:growth} die einfachste aller dieser drei Verfahren ist.


%========================================
\subsection{Fazit}
\label{sec:summary}
Ist also möglichst ein optimales Ergebnis bevorzugt, so kann man auf totale Pivotsuche zugreifen, 
braucht man jedoch ein schnelles Suchverfahren, steht die partielle Pivotsuche zur Verfügung, 
möchte man aber etwas von den beiden Welten haben, so kann man auf Rook-Pivotsuche zurückgreifen.



\newpage
\addcontentsline{toc}{section}{Literaturverzeichnis}%
\bibliographystyle{plain}
\bibliography{citations}

\end{document}
